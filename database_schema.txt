/*
  This schema is idempotent, meaning it can be run multiple times without causing errors.
  It will create tables if they don't exist and add missing columns/constraints if needed.
*/


/* =========================================== */
/*                    TABLES                   */
/* =========================================== */

/* Employees table */
CREATE TABLE IF NOT EXISTS employees (
  id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  created_at timestamp with time zone DEFAULT timezone('utc'::text, now()) NOT NULL
);
DO $$ BEGIN
  ALTER TABLE employees ADD COLUMN IF NOT EXISTS employee_id varchar(50) NOT NULL UNIQUE;
  ALTER TABLE employees ADD COLUMN IF NOT EXISTS full_name_ar varchar(255) NOT NULL;
  ALTER TABLE employees ADD COLUMN IF NOT EXISTS full_name_en varchar(255);
  ALTER TABLE employees ADD COLUMN IF NOT EXISTS job_title varchar(255) NOT NULL;
  ALTER TABLE employees ADD COLUMN IF NOT EXISTS department varchar(255) NOT NULL;
  ALTER TABLE employees ADD COLUMN IF NOT EXISTS center varchar(255);
  ALTER TABLE employees ADD COLUMN IF NOT EXISTS phone_direct varchar(50);
  ALTER TABLE employees ADD COLUMN IF NOT EXISTS email varchar(255);
  ALTER TABLE employees ADD COLUMN IF NOT EXISTS national_id varchar(50);
  ALTER TABLE employees ADD COLUMN IF NOT EXISTS nationality varchar(100);
  ALTER TABLE employees ADD COLUMN IF NOT EXISTS gender varchar(20);
  ALTER TABLE employees ADD COLUMN IF NOT EXISTS date_of_birth date;
  ALTER TABLE employees ADD COLUMN IF NOT EXISTS classification_id varchar(50);
  ALTER TABLE employees ADD COLUMN IF NOT EXISTS updated_at timestamp with time zone;
END $$;

/* Office contacts table */
CREATE TABLE IF NOT EXISTS office_contacts (
  id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  created_at timestamp with time zone DEFAULT timezone('utc'::text, now()) NOT NULL
);
DO $$ BEGIN
  ALTER TABLE office_contacts ADD COLUMN IF NOT EXISTS name varchar(255) NOT NULL UNIQUE;
  ALTER TABLE office_contacts ADD COLUMN IF NOT EXISTS extension varchar(20) NOT NULL;
  ALTER TABLE office_contacts ADD COLUMN IF NOT EXISTS location varchar(255);
  ALTER TABLE office_contacts ADD COLUMN IF NOT EXISTS email varchar(255);
  ALTER TABLE office_contacts ADD COLUMN IF NOT EXISTS updated_at timestamp with time zone;
END $$;

/* Tasks table */
CREATE TABLE IF NOT EXISTS tasks (
  id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  created_at timestamp with time zone DEFAULT timezone('utc'::text, now()) NOT NULL
);
DO $$ BEGIN
  ALTER TABLE tasks ADD COLUMN IF NOT EXISTS title text NOT NULL;
  ALTER TABLE tasks ADD COLUMN IF NOT EXISTS description text;
  ALTER TABLE tasks ADD COLUMN IF NOT EXISTS due_date date;
  ALTER TABLE tasks ADD COLUMN IF NOT EXISTS is_completed boolean NOT NULL DEFAULT false;
  ALTER TABLE tasks ADD COLUMN IF NOT EXISTS updated_at timestamp with time zone;
END $$;

/* Transactions table */
CREATE TABLE IF NOT EXISTS transactions (
  id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  created_at timestamp with time zone DEFAULT timezone('utc'::text, now()) NOT NULL
);
DO $$ BEGIN
  ALTER TABLE transactions ADD COLUMN IF NOT EXISTS transaction_number text NOT NULL UNIQUE;
  ALTER TABLE transactions ADD COLUMN IF NOT EXISTS subject text NOT NULL;
  ALTER TABLE transactions ADD COLUMN IF NOT EXISTS type text NOT NULL;
  ALTER TABLE transactions ADD COLUMN IF NOT EXISTS platform text NOT NULL;
  ALTER TABLE transactions ADD COLUMN IF NOT EXISTS status text NOT NULL;
  ALTER TABLE transactions ADD COLUMN IF NOT EXISTS date date NOT NULL;
  ALTER TABLE transactions ADD COLUMN IF NOT EXISTS description text;
  ALTER TABLE transactions ADD COLUMN IF NOT EXISTS attachment jsonb;
  ALTER TABLE transactions ADD COLUMN IF NOT EXISTS linked_employee_id bigint;
  ALTER TABLE transactions ADD COLUMN IF NOT EXISTS linked_office_contact_id bigint;
  ALTER TABLE transactions ADD COLUMN IF NOT EXISTS updated_at timestamp with time zone;
END $$;

/* Policies table */
CREATE TABLE IF NOT EXISTS policies (
  id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  created_at timestamp with time zone DEFAULT timezone('utc'::text, now()) NOT NULL,
  title text NOT NULL,
  description text,
  file_name text NULL, /* To store the file path for deletion from storage */
  file_url text NULL
);
DO $$ BEGIN
  ALTER TABLE policies ADD COLUMN IF NOT EXISTS display_file_name text NULL; /* To store the original user-friendly file name */
END $$;

/* =========================================== */
/*          NEW RBAC & LOG TABLES              */
/* =========================================== */

CREATE TABLE IF NOT EXISTS roles (
  role_id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  role_name varchar(50) NOT NULL UNIQUE,
  description text
);

CREATE TABLE IF NOT EXISTS users (
  user_id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  username varchar(50) NOT NULL UNIQUE,
  password text NOT NULL,
  full_name varchar(100) NOT NULL,
  role_id bigint,
  is_active boolean NOT NULL DEFAULT true,
  created_at timestamp with time zone DEFAULT timezone('utc'::text, now()) NOT NULL
);

CREATE TABLE IF NOT EXISTS permissions (
  permission_id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  permission_name varchar(100) NOT NULL UNIQUE,
  description text
);

CREATE TABLE IF NOT EXISTS role_permissions (
  role_id bigint NOT NULL,
  permission_id bigint NOT NULL,
  PRIMARY KEY (role_id, permission_id)
);

/* Logos table */
create table if not exists logos (
  id bigint generated always as identity primary key,
  name text not null,
  image_url text not null,
  uploaded_at timestamp with time zone default now()
);

/* Activity Log table */
CREATE TABLE IF NOT EXISTS activity_log (
  id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  created_at timestamp with time zone DEFAULT timezone('utc'::text, now()) NOT NULL
);
DO $$ BEGIN
  /*
    Columns are made nullable to prevent migration errors on tables with existing data from before these columns were added.
    The application logic ensures these columns are populated for new entries.
  */
  ALTER TABLE activity_log ADD COLUMN IF NOT EXISTS user_id bigint;
  ALTER TABLE activity_log ADD COLUMN IF NOT EXISTS user_full_name text;
  ALTER TABLE activity_log ADD COLUMN IF NOT EXISTS action text;
  ALTER TABLE activity_log ADD COLUMN IF NOT EXISTS action_type text;
  ALTER TABLE activity_log ADD COLUMN IF NOT EXISTS details jsonb;
  ALTER TABLE activity_log DROP COLUMN IF EXISTS description;
END $$;

/* =========================================== */
/*                STORAGE SETUP                */
/* =========================================== */

/*
  Create the 'policies' bucket for policy documents.
  It's public to allow direct URL access to the PDFs.
*/
INSERT INTO storage.buckets (id, name, public)
VALUES ('policies', 'policies', true)
ON CONFLICT (id) DO NOTHING;


/* =========================================== */
/*          FOREIGN KEY CONSTRAINTS            */
/* =========================================== */
DO $$ BEGIN
  IF NOT EXISTS (SELECT 1 FROM pg_constraint WHERE conname = 'transactions_linked_employee_id_fkey') THEN
    ALTER TABLE transactions ADD CONSTRAINT transactions_linked_employee_id_fkey FOREIGN KEY (linked_employee_id) REFERENCES employees(id) ON DELETE SET NULL;
  END IF;
  IF NOT EXISTS (SELECT 1 FROM pg_constraint WHERE conname = 'transactions_linked_office_contact_id_fkey') THEN
    ALTER TABLE transactions ADD CONSTRAINT transactions_linked_office_contact_id_fkey FOREIGN KEY (linked_office_contact_id) REFERENCES office_contacts(id) ON DELETE SET NULL;
  END IF;
  IF NOT EXISTS (SELECT 1 FROM pg_constraint WHERE conname = 'users_role_id_fkey') THEN
    ALTER TABLE users ADD CONSTRAINT users_role_id_fkey FOREIGN KEY (role_id) REFERENCES roles(role_id) ON DELETE RESTRICT;
  END IF;
  IF NOT EXISTS (SELECT 1 FROM pg_constraint WHERE conname = 'role_permissions_role_id_fkey') THEN
    ALTER TABLE role_permissions ADD CONSTRAINT role_permissions_role_id_fkey FOREIGN KEY (role_id) REFERENCES roles(role_id) ON DELETE CASCADE;
  END IF;
  IF NOT EXISTS (SELECT 1 FROM pg_constraint WHERE conname = 'role_permissions_permission_id_fkey') THEN
    ALTER TABLE role_permissions ADD CONSTRAINT role_permissions_permission_id_fkey FOREIGN KEY (permission_id) REFERENCES permissions(permission_id) ON DELETE CASCADE;
  END IF;
   IF NOT EXISTS (SELECT 1 FROM pg_constraint WHERE conname = 'activity_log_user_id_fkey') THEN
    ALTER TABLE activity_log ADD CONSTRAINT activity_log_user_id_fkey FOREIGN KEY (user_id) REFERENCES users(user_id) ON DELETE SET NULL;
  END IF;
END $$;

/* =========================================== */
/*            PERMISSIONS (GRANTS)             */
/* =========================================== */

/*
  Grant usage on the storage schema and permissions on its tables/functions.
  This is crucial for allowing file uploads/downloads via RLS policies.
*/
GRANT USAGE ON SCHEMA storage TO anon, authenticated;
GRANT ALL ON TABLE storage.buckets TO anon, authenticated;
GRANT ALL ON TABLE storage.objects TO anon, authenticated;
GRANT EXECUTE ON ALL FUNCTIONS IN SCHEMA storage TO anon, authenticated;

/* Although we use RLS with `USING (true)`, explicitly granting permissions on public tables is a good practice. */
GRANT SELECT, INSERT, UPDATE, DELETE ON ALL TABLES IN SCHEMA public TO anon, authenticated;
GRANT USAGE, SELECT, UPDATE ON ALL SEQUENCES IN SCHEMA public TO anon, authenticated;

/* =========================================== */
/*           ROW LEVEL SECURITY (RLS)          */
/* =========================================== */
ALTER TABLE employees ENABLE ROW LEVEL SECURITY;
ALTER TABLE office_contacts ENABLE ROW LEVEL SECURITY;
ALTER TABLE tasks ENABLE ROW LEVEL SECURITY;
ALTER TABLE transactions ENABLE ROW LEVEL SECURITY;
ALTER TABLE users ENABLE ROW LEVEL SECURITY;
ALTER TABLE roles ENABLE ROW LEVEL SECURITY;
ALTER TABLE permissions ENABLE ROW LEVEL SECURITY;
ALTER TABLE role_permissions ENABLE ROW LEVEL SECURITY;
ALTER TABLE logos ENABLE ROW LEVEL SECURITY;
ALTER TABLE activity_log ENABLE ROW LEVEL SECURITY;
ALTER TABLE policies ENABLE ROW LEVEL SECURITY;
/*
  RLS on storage.objects is enabled by default in Supabase.
  Attempting to re-enable it can cause permission errors if not run by the owner.
  The policies below will work correctly without this line.
*/

/* Drop old policies to replace them */
DROP POLICY IF EXISTS "Enable public read access" ON employees;
DROP POLICY IF EXISTS "Allow all for authenticated users" ON employees;
DROP POLICY IF EXISTS "Allow all for any user" ON employees;

DROP POLICY IF EXISTS "Enable public read access" ON office_contacts;
DROP POLICY IF EXISTS "Allow all for authenticated users" ON office_contacts;
DROP POLICY IF EXISTS "Allow all for any user" ON office_contacts;

DROP POLICY IF EXISTS "Enable public read access" ON tasks;
DROP POLICY IF EXISTS "Allow all for authenticated users" ON tasks;
DROP POLICY IF EXISTS "Allow all for any user" ON tasks;

DROP POLICY IF EXISTS "Enable public read access" ON transactions;
DROP POLICY IF EXISTS "Allow all for authenticated users" ON transactions;
DROP POLICY IF EXISTS "Allow all for any user" ON transactions;

DROP POLICY IF EXISTS "Enable public read access" ON users;
DROP POLICY IF EXISTS "Allow all for authenticated users" ON users;
DROP POLICY IF EXISTS "Allow all for any user" ON users;

DROP POLICY IF EXISTS "Enable public read access" ON roles;
DROP POLICY IF EXISTS "Allow all for authenticated users" ON roles;
DROP POLICY IF EXISTS "Allow all for any user" ON roles;

DROP POLICY IF EXISTS "Enable public read access" ON permissions;
DROP POLICY IF EXISTS "Allow all for authenticated users" ON permissions;
DROP POLICY IF EXISTS "Allow all for any user" ON permissions;

DROP POLICY IF EXISTS "Enable public read access" ON role_permissions;
DROP POLICY IF EXISTS "Allow all for authenticated users" ON role_permissions;
DROP POLICY IF EXISTS "Allow all for any user" ON role_permissions;

DROP POLICY IF EXISTS "Enable public read access" ON logos;
DROP POLICY IF EXISTS "Allow all for authenticated users" ON logos;
DROP POLICY IF EXISTS "Allow all for any user" ON logos;

DROP POLICY IF EXISTS "Allow all for authenticated users" ON activity_log;
DROP POLICY IF EXISTS "Allow insert for authenticated users" ON activity_log;
DROP POLICY IF EXISTS "Allow select for authenticated users" ON activity_log;
DROP POLICY IF EXISTS "Allow insert for any user" ON activity_log;
DROP POLICY IF EXISTS "Allow select for any user" ON activity_log;

DROP POLICY IF EXISTS "Enable public read access for policies" ON policies;
DROP POLICY IF EXISTS "Allow authenticated users to manage policies" ON policies;
DROP POLICY IF EXISTS "Allow all for any user on policies" ON policies;

DROP POLICY IF EXISTS "Allow all access to policies bucket" ON storage.objects;

/*
  FIX: The original policies used `auth.role() = 'authenticated'`, which fails with the app's custom authentication.
  The new policies use `USING (true)` and `WITH CHECK (true)` to allow access for any client with the anon key,
  as authentication is handled within the application itself. This will allow all operations to succeed and be logged.
*/

CREATE POLICY "Allow all for any user" ON employees FOR ALL USING (true) WITH CHECK (true);
CREATE POLICY "Allow all for any user" ON office_contacts FOR ALL USING (true) WITH CHECK (true);
CREATE POLICY "Allow all for any user" ON tasks FOR ALL USING (true) WITH CHECK (true);
CREATE POLICY "Allow all for any user" ON transactions FOR ALL USING (true) WITH CHECK (true);
CREATE POLICY "Allow all for any user" ON users FOR ALL USING (true) WITH CHECK (true);
CREATE POLICY "Allow all for any user" ON roles FOR ALL USING (true) WITH CHECK (true);
CREATE POLICY "Allow all for any user" ON permissions FOR ALL USING (true) WITH CHECK (true);
CREATE POLICY "Allow all for any user" ON role_permissions FOR ALL USING (true) WITH CHECK (true);
CREATE POLICY "Allow all for any user" ON logos FOR ALL USING (true) WITH CHECK (true);

/* Policies for activity_log are already correct, but we define them here for consistency. */
CREATE POLICY "Allow insert for any user" ON activity_log FOR INSERT WITH CHECK (true);
CREATE POLICY "Allow select for any user" ON activity_log FOR SELECT USING (true);

/* Policies for policies table */
CREATE POLICY "Allow all for any user on policies" ON policies
  FOR ALL USING (true) WITH CHECK (true);

/* Policies for storage */
CREATE POLICY "Allow all access to policies bucket" ON storage.objects
  FOR ALL
  USING (bucket_id = 'policies')
  WITH CHECK (bucket_id = 'policies');


/* =========================================== */
/*                SEEDING DATA                 */
/* =========================================== */
DO $$
DECLARE
  admin_role_id bigint;
  hr_manager_role_id bigint;
  user_role_id bigint;
BEGIN
  /* 1. Seed Roles */
  INSERT INTO roles (role_name, description) VALUES
  ('Admin', 'Administrator with full system access'),
  ('HR_Manager', 'Human Resources Manager with access to employee data'),
  ('User', 'Standard user with limited access, configurable by admin')
  ON CONFLICT (role_name) DO NOTHING;

  SELECT role_id INTO admin_role_id FROM roles WHERE role_name = 'Admin';
  SELECT role_id INTO hr_manager_role_id FROM roles WHERE role_name = 'HR_Manager';
  SELECT role_id INTO user_role_id FROM roles WHERE role_name = 'User';

  /* 2. Seed Permissions */
  INSERT INTO permissions (permission_name, description) VALUES
  ('manage_users', 'Can add, edit, and deactivate users and manage roles/permissions'),
  ('edit_employees', 'Can add and edit employee records'),
  ('delete_employees', 'Can delete employee records'),
  ('import_export_employees', 'Can import and export employee data'),
  ('edit_contacts', 'Can add and edit office contacts'),
  ('delete_contacts', 'Can delete office contacts'),
  ('import_export_contacts', 'Can import and export office contacts'),
  ('edit_tasks', 'Can edit any task'),
  ('delete_tasks', 'Can delete any task'),
  ('edit_transactions', 'Can edit any transaction'),
  ('delete_transactions', 'Can delete any transaction'),
  ('add_task', 'Can add a new task'),
  ('add_transaction', 'Can add a new transaction'),
  ('view_activity_log', 'Can view the system activity log'),
  ('manage_policies', 'Can add, edit, and delete governance policies')
  ON CONFLICT (permission_name) DO NOTHING;

  /* 3. Seed Role_Permissions (clear existing before seeding) */
  DELETE FROM role_permissions;

  /* Admin permissions (all) */
  INSERT INTO role_permissions (role_id, permission_id)
  SELECT admin_role_id, p.permission_id FROM permissions p;

  /* HR Manager permissions */
  INSERT INTO role_permissions (role_id, permission_id)
  SELECT hr_manager_role_id, p.permission_id
  FROM permissions p
  WHERE p.permission_name IN (
    'edit_employees', 'delete_employees', 'import_export_employees'
  );

  /* Viewer has no insert/edit/delete permissions by default. */
  /* The 'User' role has no permissions by default; admin must configure. */

  /* 4. Seed default Admin User if no users exist */
  IF NOT EXISTS (SELECT 1 FROM users) THEN
    INSERT INTO users (username, password, full_name, role_id)
    VALUES ('admin', 'admin', 'Admin User', admin_role_id);
  END IF;

END;
$$;